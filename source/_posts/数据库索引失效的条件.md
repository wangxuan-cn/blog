---
title: 数据库索引失效的条件
date: 2018-04-22 18:29:35
tags:
    - MySQL
    - SQL优化
categories:
    - 数据库
    - MySQL
---
几乎所有的小伙伴都可以随口说几句关于创建索引的优缺点，也知道什么时候创建索引能够提高我们的查询性能，什么时候索引会更新，但是你有没有注意到，即使你设置了索引，有些时候索引他是不会生效的！这不仅考察了大家对索引的了解程度，还要让大家在使用的时候能够正确的使用。以下介绍了一些可能会造成索引失效的特殊情况，希望大家在平时开发和面试的时候能够注意到！
# 如何判断数据库索引是否生效
首先在接着探讨之前，我们先说一下，如何判断数据库的索引是否生效！相信大家应该猜到了，就是explain！explain显示了MySQL如何使用索引来处理select语句以及连接表。他可以帮助选择更好的索引和写出更优化的查询语句。
例如我们有一张表user，为name列创建索引name_index，如下所示：
![](/images/数据库索引失效的条件/1.1.jpg)
使用explain分析语句如下：
![](/images/数据库索引失效的条件/1.2.jpg)

可以看到，使用explain显示了很多列，各个关键字的含义如下：
- table：顾名思义，显示这一行的数据是关于哪张表的；
- type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为：const、eq_reg、ref、range、indexhe和ALL；
- possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句；
- key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在Select语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引；
- key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好；
- ref：显示索引的哪一列被使用了，如果可能的话，是一个常数；
- rows：MySQL认为必须检查的用来返回请求数据的行数；
- Extra：关于MySQL如何解析查询的额外信息。

具体的各个列所能表示的值以及含义可以参考MySQL官方文档介绍，地址：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html

# 哪些场景会造成索引生效
1. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则引擎将放弃使用索引而进行全表扫描；
![](/images/数据库索引失效的条件/2.1.jpg)
2. 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，即使其中有条件带索引也不会使用，这也是为什么尽量少用 or 的原因；
![](/images/数据库索引失效的条件/2.2.jpg)
3. 对于多列索引，不是使用的第一部分，则不会使用索引；
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引；
![](/images/数据库索引失效的条件/2.3.jpg)
5. like的模糊查询以 % 开头，索引失效；
![](/images/数据库索引失效的条件/2.4.jpg)
6. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描；
如：
`select id from t where num/2 = 100;`
以abc开头的，应改成：
`select id from t where num = 100*2;`
7. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描；
例如：
`select id from t where substring(name,1,3) = 'abc' – name;`
以abc开头的，应改成：
`select id from t where name like 'abc%';`
例如：
`select id from t where datediff(day, createdate, '2005-11-30') = 0 – '2005-11-30';`
应改为:
`select id from t where createdate >= '2005-11-30' and createdate < '2005-12-1';`
8. 不要在 where 子句中的 "=" 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引；
9. 如果MySQL估计使用全表扫描要比使用索引快，则不使用索引；
10. 不适合键值较少的列（重复数据较多的列）

假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问表中的2000个数据块。再加上访问索引块，一共要访问大于200个的数据块。如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块少一些，肯定就不会利用索引了。
